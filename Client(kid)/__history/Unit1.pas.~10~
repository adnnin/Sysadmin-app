unit Unit1;

interface

uses
  Winapi.Windows, ActiveX, ComObj, Registry, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,ShellAPI, System.Win.ScktComp, Vcl.StdCtrls,
  Vcl.ComCtrls;

type
  TClientHost = class(TForm)
    ClientSocket1: TClientSocket;
    Button1: TButton;
    Memo1: TMemo;
    RichEdit1: TRichEdit;
    procedure FormCreate(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure ClientSocket1Read(Sender: TObject; Socket: TCustomWinSocket);
  private
    procedure TryConnection(IP, Port: string);
    { Private declarations }
  public
    { Public declarations }
  end;

var
  ClientHost: TClientHost;

implementation
{$R *.dfm}

//procedure hello;
//Begin
//  Showmessage ('hello world');
//End;

procedure TClientHost.Button1Click(Sender: TObject);
begin
  TryConnection('192.168.1.5', '65530');
end;

procedure TClientHost.TryConnection(IP, Port : string);
begin
   try
    ClientSocket1.Port:=Port.ToInteger;
    ClientSocket1.Address:= IP;
    ClientSocket1.Open
  except
    ShowMessage('Я не смог подключится к папе...')
  end;

end;

procedure TClientHost.ClientSocket1Read(Sender: TObject;
  Socket: TCustomWinSocket);
   const
      WbemUser            ='';
      WbemPassword        ='';
      WbemComputer        ='localhost';
      wbemFlagForwardOnly = $00000020;
      var
      FSWbemLocator : OLEVariant;
      FWMIService   : OLEVariant;
      FWbemObjectSet: OLEVariant;
      FWbemObject   : OLEVariant;
      oEnum         : IEnumvariant;
      iValue        : LongWord;
      ArchCPU, TypeCPU:string;
var
  Command : string;
  R: TRegistry;
  RegPath: string;
begin
  memo1.Lines.Add('-----------');

  Command := Socket.ReceiveText;

  memo1.Lines.Add('Мне прислали команду ' + Command);

  if Command = '[Выключить_ПК]' then
  Begin
    memo1.Lines.Add('Я принял её! ' + Command);

    memo1.Lines.Add('Начинаю Выключение ПК!');

    ShellExecute(handle, nil, 'cmd.exe', PCHar('cmd /c shutdown /s'),nil, SW_HIDE);
  End;

  if Command = '[Перезагрузить_ПК]' then
  Begin
    memo1.Lines.Add('Я принял её! ' + Command);

    memo1.Lines.Add('Начинаю перезагрузку ПК!');

    ShellExecute(handle, nil, 'cmd.exe', PCHar('cmd /c shutdown /r'),nil, SW_HIDE);
  End;


  if Command = '[Получить_ттх_пк]' then

  begin
    memo1.Lines.Add('Я принял её! ' + Command);

    memo1.Lines.Add('Сохраняю инфу о ПК');

    var strm := TStringList.Create;

    var Put := ExtractFileDir(ParamStr(0))+'\sysInfo.txt';
    var outfile: TextFile;
    AssignFile(outfile, 'outfile.txt');
    Rewrite(outfile);

    strm.SaveToFile(Put); //создаю файл быстрым костылем))





    ShellExecute(handle, nil, 'cmd.exe', PCHar('cmd /c chcp 1251 && systeminfo > C:\Users\bazyl\test2.txt'),nil, SW_HIDE);

          begin;
      FSWbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
      FWMIService   := FSWbemLocator.ConnectServer(WbemComputer, 'root\CIMV2', WbemUser, WbemPassword);
      FWbemObjectSet:= FWMIService.ExecQuery('SELECT * FROM Win32_Processor','WQL',wbemFlagForwardOnly);
      oEnum         := IUnknown(FWbemObjectSet._NewEnum) as IEnumVariant;
      while oEnum.Next(1, FWbemObject, iValue) = 0 do
      begin
      case FWbemObject.Architecture of
      0 :ArchCPU :='x86';
      9: ArchCPU :='x64';
      end;

      case FWbemObject.ProcessorType of
      1: TypeCPU :='Другое';
      2: TypeCPU :='Неизвестный';
      3: TypeCPU :='Центральный процессор';
      4: TypeCPU :='Математический процессор';
      5: TypeCPU :='DSP процессор';
      6: TypeCPU :='Видеопроцессор';
      end;
      Memo1.Clear;


      Memo1.Lines.Add(Format('Имя:                          %s',[String(FWbemObject.Name)]));// String
      Memo1.Lines.Add(Format('Архитектура:                  %s',[ArchCPU]));// Uint16
      Memo1.Lines.Add(Format('Производитель:                %s',[String(FWbemObject.Manufacturer)]));// String
      Memo1.Lines.Add(Format('Описание:                     %s',[String(FWbemObject.Caption)]));// String
      Memo1.Lines.Add(Format('Тип:                           %s',[TypeCPU]));// Uint16
      Memo1.Lines.Add(Format('Тип сокета:                   %s',[String(FWbemObject.SocketDesignation)]));// String
      Memo1.Lines.Add(Format('Число ядер:                   %d',[Integer(FWbemObject.NumberOfCores)]));// Uint32
      Memo1.Lines.Add(Format('Число используемых ядер:          %d',[Integer(FWbemObject.NumberOfEnabledCore)]));// Uint32
      Memo1.Lines.Add(Format('Число логических процессоров:     %d',[Integer(FWbemObject.NumberOfLogicalProcessors)]));// Uint32
      Memo1.Lines.Add(Format('Статус:                           %s',[String(FWbemObject.Status)]));// String
      Memo1.Lines.Add('');


      //FWbemObject :=Unassigned;
      end;
      end;
      // ShowMessage('Производитель: '+R.ReadString('VendorIdentifier'));
      // ShowMessage('Семейство: '+R.ReadString('Identifier'));
      // ShowMessage(Format('Производитель: %s'#13'Семейство: %s'#13'Название: %s', [R.ReadString('VendorIdentifier'), R.ReadString('Identifier'), R.ReadString('ProcessorNameString')]));
    //   Аналогично сделать чтобы писало в файл


    memo1.Lines.Add('Читае инфу из файла');

    try
      strm.LoadFromFile('C:\Users\bazyl\test2.txt');
    except
      memo1.Lines.Add('Файл не прочитан...');

      exit;
    end;

   memo1.Lines.Add('Файл прочитался, его текст: ' + strm.Text);


    //сча тут действия можно поо ней, например дадим ответ что мы пизданули его

    Socket.SendText(strm.Text);

    memo1.Lines.Add('Папе ответил!');

  end
  else
  begin
    Socket.SendText('ERROR! Команда ' + Command + ' не дошла...');
    memo1.Lines.Add('ERROR! Команда ' + Command + ' не дошла...');
  end;

  memo1.Lines.Add('-----------');

end;

procedure TClientHost.FormCreate(Sender: TObject);
begin
  Memo1.Font.Charset:=OEM_CHARSET;   //кодировка для memo
  TryConnection('192.168.1.5', '65530');


end;


end.
